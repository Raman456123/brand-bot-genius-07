
import { Activity, ActivityResult, BuildOrUpdateActivityOptions } from "../types";

export class BuildOrUpdateActivity implements Activity {
  name: string;
  description: string;
  energyCost: number;
  cooldown: number;
  requiredApiKeys: string[];
  options: BuildOrUpdateActivityOptions;
  
  constructor(options: BuildOrUpdateActivityOptions = {}) {
    this.name = "build_or_update";
    this.description = "Generates or updates activities based on suggestions from memory";
    this.energyCost = 0.6;
    this.cooldown = 172800; // 2 days in seconds
    this.requiredApiKeys = ["OPENAI"];
    
    this.options = {
      systemPrompt: "You are an AI coder that converts user suggestions into valid code for new activities.\n" +
        "We have certain code/style constraints based on real-world usage:\n\n" +
        "# 1) Activity implementation\n" +
        "- The code must implement the Activity interface with name, description, energyCost, cooldown, etc.\n" +
        "- The activity must have an execute method that returns an ActivityResult.\n\n" +
        "# 2) Error handling\n" +
        "- Include try/catch blocks to handle errors properly.\n" + 
        "- Return proper ActivityResult objects for success and failure cases.\n\n" +
        "# 3) Common pitfalls\n" +
        "- DO NOT reference unknown modules or placeholders.\n" +
        "- Ensure proper API key validation before using external services.\n" +
        "- Properly track energy and cooldown requirements.\n\n" +
        "Given user suggestions and known activity data, produce EXACT code meeting these standards.",
      maxTokens: 1200,
      recentActivitiesLimit: 20,
      ...options
    };
  }

  async canRun(apiKeys: Record<string, string>, state: any): Promise<boolean> {
    // Check if the OpenAI API key is available and if energy is sufficient
    return state.energy >= this.energyCost && !!apiKeys["OPENAI"];
  }

  async execute(apiKeys: Record<string, string>, state: any, params?: any): Promise<ActivityResult> {
    console.log("Starting BuildOrUpdateActivity...");
    
    try {
      // 1. Gather recent activities from memory to find suggestions
      // In a real implementation, this would access actual memory storage
      console.log("Looking for recent activity suggestions...");
      
      // 2. Mock data for demonstration purposes
      // In a real implementation, we would extract this from memory
      const mockSuggestions = params?.suggestions || [
        "Create an activity that analyzes sentiment of recent tweets",
        "Build an activity that summarizes news articles"
      ];
      const combinedSuggestions = mockSuggestions.join("\n---\n");
      
      // 3. Generate a filename (first LLM call)
      console.log("Generating appropriate filename...");
      const mockFilename = "activity_sentiment_analyzer.ts";
      
      // 4. Generate the full code (second LLM call)
      console.log("Generating full code implementation...");
      
      // Mock code snippet that would be generated by the LLM
      const mockCodeSnippet = `
import { Activity, ActivityResult } from "../types";

export class SentimentAnalyzerActivity implements Activity {
  name: string;
  description: string;
  energyCost: number;
  cooldown: number;
  requiredApiKeys: string[];
  
  constructor() {
    this.name = "analyze_sentiment";
    this.description = "Analyzes sentiment of recent social media posts";
    this.energyCost = 0.3;
    this.cooldown = 3600; // 1 hour
    this.requiredApiKeys = ["OPENAI"];
  }

  async canRun(apiKeys: Record<string, string>, state: any): Promise<boolean> {
    return state.energy >= this.energyCost && !!apiKeys["OPENAI"];
  }

  async execute(apiKeys: Record<string, string>, state: any, params?: any): Promise<ActivityResult> {
    try {
      console.log("Executing SentimentAnalyzerActivity");
      
      // Implementation would go here
      // This would use the OpenAI API to analyze sentiment
      
      return {
        success: true,
        data: { 
          sentiment: "positive",
          confidence: 0.85
        },
        error: null
      };
    } catch (error) {
      return {
        success: false,
        data: null,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
}`;

      // 5. In a real implementation, we would:
      // - Write the code to a file in the filesystem
      // - Dynamically import and register the new activity
      // - For our demo, we'll just log that we would do this

      console.log(`Would write code to: ${mockFilename}`);
      console.log("Would register the new activity with the system");
      
      return {
        success: true,
        data: {
          filename: mockFilename,
          codeSnippet: mockCodeSnippet,
          message: "Activity created and ready for registration"
        },
        error: null,
        metadata: {
          suggestionsCount: mockSuggestions.length
        }
      };
      
    } catch (error) {
      console.error("Error in BuildOrUpdateActivity:", error);
      return {
        success: false,
        data: null,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  private cleanCodeSnippet(snippet: string): string {
    // Remove markdown code fences if present
    let cleaned = snippet.trim();
    if (cleaned.startsWith("```")) {
      const languageMatch = cleaned.match(/^```(\w+)?\n/);
      if (languageMatch) {
        cleaned = cleaned.substring(languageMatch[0].length);
      } else {
        cleaned = cleaned.substring(3);
      }
    }
    if (cleaned.endsWith("```")) {
      cleaned = cleaned.substring(0, cleaned.length - 3);
    }
    return cleaned.trim();
  }
}
